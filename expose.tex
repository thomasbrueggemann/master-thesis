%
% Expose: Master Thesis
% Thomas Brüggemann
%

% -----------
% 1. Präambel
% -----------

% Allgemeine Einstellungen
% ------------------------
\documentclass[
	a4paper,
	oneside,
	12pt,
	liststotocnumbered
]{article}
\usepackage{times}            % Times New Roman

\usepackage[utf8]{inputenc}   % utf-8
\usepackage[english]{babel}    % english hyphenation
\selectlanguage{english}       % english titles
\usepackage{nicefrac} 
\usepackage{longtable}

% Titel-Font-Größen
\usepackage{titlesec}
\titleformat{\section}{\bfseries}{\thesection.}{12pt}{}
\titleformat{\subsection}{\bfseries}{\thesubsection }{12pt}{}

% Seitenränder
\usepackage[
    top=2.5cm, 
    bottom=2.5cm, 
    left=5cm, 
    right=1cm
]{geometry} 

% Fussnoten
\usepackage[hang,flushmargin]{footmisc}    
\renewcommand*{\footnotelayout}{\footnotesize} % size of text
\renewcommand{\footnotemargin}{2.2em}          % margin between text and number
\setlength{\footnotesep}{1.3em}                % space between footnotes
\setlength{\skip\footins}{2.5em}               % space between text & footnotes
\usepackage{savefnmark}

% Abkürzungen
\usepackage[printonlyused]{acronym}    
\renewcommand{\bflabel}[1]{{#1\hfill}}

% Seitennummerierung oben
\usepackage{scrpage2} 
\usepackage[dvips]{color}
\clearscrheadfoot 
\chead[\pagemark]{\textcolor[gray]{0.5}{\pagemark}} 
\pagestyle{scrheadings}

% TOC, LOF, FIG Styles
\usepackage{tocloft, titletoc}  
\setlength{\cftaftertoctitleskip}{0em}
\renewcommand{\cftloftitlefont}{\bfseries}
%\renewcommand{\cftfigfont}{\bfseries}
\renewcommand{\cfttoctitlefont}{\bfseries}
\renewcommand{\cftlottitlefont}{\bfseries}
\titlecontents{section}     % set formatting for \section 
[2.3em]                     % adjust left margin
{\vspace{0.5em}}            % font formatting
{\hspace{-1.8em}.\contentslabel{0.7em}\hspace{1em}} % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}

\titlecontents{subsection}  % set formatting for \subsection 
[3em]                       % adjust left margin
{\vspace{0.5em}}            % font formatting
{\contentslabel{2.3em}}     % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}

\titlecontents{subsubsection}  % set formatting for \subsubsection 
[4.2em]                       % adjust left margin
{\vspace{0.5em}}            % font formatting
{\contentslabel{2.3em}}     % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}

\titlecontents{figure}      % set formatting for \subsection 
[2.3em]                     % adjust left margin
{\vspace{0.5em}}            % font formatting
{\contentslabel{2.3em}}     % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}

\titlecontents{table}       % set formatting for \subsection 
[3.4em]                     % adjust left margin
{\vspace{0.5em}}            % font formatting
{:\hspace*{0.9em}\contentslabel{4.5em}}     % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}


% Literaturverzeichnis
\usepackage[
    bibstyle=authortitle,
    citestyle=authoryear,
    backend=biber,
    isbn=false,
    url=false,
    doi=false,
    maxcitenames=3,
    maxbibnames=30
]{biblatex}
\addbibresource{library.bib}
\let\cite\textcite

\usepackage{caption}
\usepackage{chngcntr}

% Tabellenpackete
\usepackage{array}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{setspace}
\counterwithin{table}{section}
\usepackage{multirow}
\usepackage{colortbl}

% Grafiken anzeigen
\usepackage[pdftex]{graphicx}
\graphicspath{{figures}}
\counterwithin{figure}{section}
\usepackage[absolute,overlay]{textpos}

\begin{document}

% Renews
\renewcommand{\figurename}{Figure}
\renewcommand{\tablename}{Table}
\renewcommand\thefigure{\arabic{section}-\arabic{figure}}
\renewcommand\thetable{Tab. \arabic{section}-\arabic{table}}
\newcommand{\todo}[1]{\textbf{\textsc{\textcolor{red}{TODO: #1}}}}

% Variables
\newcommand{\mH}{mHealth }
\newcommand{\ap}{app provider}
\newcommand{\pp}{privacy policy}
\newcommand{\pps}{privacy policies}
\newcommand{\sca}{static code analysis}
\newcommand{\Sca}{Static code analysis}

\pagenumbering{Roman}

% Deckblatt
% ---------
\include{titlepages/cover}

% Inhaltsverzeichnis anzeigen
% ---------------------------
\tocloftpagestyle{scrheadings}
\tableofcontents
\newpage

% Abkürzungsverzeichnis
\section*{Index of Abbreviations}
\addcontentsline{toc}{section}{Index of Abbreviations}
\begin{acronym}[TTTTTTTTTTTTTTTTTTTT]
	\acro{API}{Application Programming Interface}
	\acro{APK}{Android Application Package}
	\acro{DEX}{Dalvik Executable}
	\acro{DRM}{Digital Rights Management}
	\acro{HTTP}{Hypertext Transfer Protocol}
	\acro{JAR}{Java Archive}
	\acro{JVM}{Java Virtual Machine}
    \acro{mHealth}{Mobile Health}
    \acro{XML}{Extensible Markup Language}
\end{acronym}
\newpage

\normalsize
\setstretch{1,5}
\pagenumbering{arabic}

% PROBLEM STATEMENT %
\section{Problem Statement}
The market for mobile smartdevice applications (apps) is growing extensively in recent years.
It is increasingly easier for companies or even single developers to create unique apps that reach millions of users around the planet via digital app stores.\footnote{Previous two sentences following \cite{Enck2011}, p. 1}
This market growth effected mobile health (\acs{mHealth}) apps as well. 
More and more \mH apps are available that support the users in resolving their health related issues and that try to patch information deficiencies. 
The data tools and information systems that have been used and maintained in hospitals for decades are recently carried out to distributed cloud services for virtually everyone to consume.\footnote{\cite{He2014a}, p. 645}

Users are asked to expose their personal health related information, in order to receive a tailored app that fits their custom preferences.\footnote{\cite{Chen2012}, p. 2}
The users reveal vulnerable information about their health status, while it remains mostly unclear how and where the data is send, processed and stored.\footnote{\cite{He2014a}, p. 652}

The information about these privacy related practices of \ap s and their offered apps should be stated in the privacy policy document, provided by the \ap.
Processing these \pps requires a higher level of education and time to read through large bodies of text, to find the relevant information. 
Additionally, the important information is hidden in legal language or insufficiently addressed, if at all.\footnote{This paragraph follows \cite{Dehling2014}, p. 11}

Aside from the data usage beyond users control, it is also challenging for users to assess what kind of private information an app asks for, prior to the app usage. 
Users have to download the apps of interest and try them out, before it becomes clear what health related information is processed by the app and in what way. 
This leads to low inter comparability between apps. 
If users are looking for specific functionality in a \mH app, it is challenging to find the app that offers the desired functionality at an acceptable privacy risk. 
Even if users would pursue the goal to find and compare \mH apps of similar functionality, the high volume of apps available on the app stores\footnote{\cite{Enck2011}, p. 1} makes it overbearingly hard to review all of them by hand.

Resolving the challenges in evaluating the privacy risk of \mH apps, before usage and of large volumes, will result in an improved decision making process for users. 
It also reduces the danger of exposing vulnerable information. 
A way to assess privacy risks of \mH apps would be to automate the review of each individual app. 
Automating the review process for large scale app assessments has the potential to grow new privacy evaluation service markets.\footnote{\cite{Enck2011}, p. 14}
Automating the app assessment for potential privacy risk factors  can be done by downloading and analyzing the source of each app to trace data leaks. 
\Sca is used in the field of informatics to analyse application source code to detect faults or vulnerabilities.\footnote{\cite{Baca2008}, p. 79} 
A \sca could potentially be used to assess the privacy risks that mHealth apps pose.

The automated process of assessing the privacy risk helps to reduce the costs of reviewing each individual app and enhances the information experience users get while researching mHealth apps.Additionally, it exposes new possibilities for research in the privacy risk area. The research could be conducted on providing solutions and best practices for minimizing the privacy risk of apps.
It is unclear if, and to what degree, the concepts of static code analysis and privacy risk assessment can be combined in order to automate the app assessment.
This leads to the research question of this master thesis. How and to what degree can the privacy risk assessment of mHealth apps be automated?

% Related Work %
\subsection{Related Work}
\todo{Related Work bei \cite{xu2013techniques} abschauen}
Previous research in this field revealed...

% OBJECTIVES %
\section{Objectives}

The primary objective of this study is to ascertain how or to what degree the assessment of privacy risk factors for \mH apps can be automated.
This will be done by implementing a software tool that downloads, decompiles and analyses the source code of \mH apps for privacy risk factors.
The implementation process might come to a stop at some point due to insurmountable obstacles.
These possible obstacles will be documented as a result of this study.

As a secondary objective of this study, an evaluation of the privacy risk assessment tool, including an overview of the users’ opinions regarding the potential impact of the tool on their mHealth app decision making, will be given.


% DEFINITIONS %
\section{Definitions}
Certain terms are used in the remainder of this thesis that have to be defined:

% Mobile health apps
\subsection{Mobile health apps}

Mobile health \acs{mHealth} apps are smartphone or tablet applications that support the users by enabling them to gather information and support about medical or health related issues.\footnote{See \cite{Dehling2015b}, p. 1}

% Static code analysis %
\subsection{Static code analysis}

Static code analysis refers to the analysis of an applications source code without actually executing the application. 
This technique is widely used to detect vulnerabilities or to validate the source code at programming time in e.g. the code editor software. \footnote{See \cite{bardas2010static}, p. 2-3}

% Decompilation %
\subsection{Decompilation}

Compilers transfer human readable programming code into machine code and therefore help humans write software applications in understandable text form. 
Decompilers retrieve the human readable programming code back from the compiled machine code. 
They aim at reversing the compilation process.
\footnote{This section follows \cite{nolan2012decompiling}, p. 1-2}

% METHODS %
\section{Methods}

% Automating the privacy risk assessment %
\subsection{Automating the privacy risk assessment}

% android decompilation
\subsubsection{Android decompilation}

In order to automate the privacy risk assessment of \mH apps via \sca, it is necessary to gain access the source code of the apps. 
While uploading a new app to the Apple AppStore, Apple's digital rights management (\acs{DRM}) system encrypts the binary file in a way that makes recovering the source code difficult. 
There are approaches on decompiling the Apple app binary back into its source code.
These approaches involve unlocking and jailbreaking
\footnote{Jailbreaking revers to the action of removing ... \cite{Kweller2010}, p. 1}
an Apple iPhone or iPad, which is a violation of the Apple terms of service and therefore forbidden\footnote{\cite{Kweller2010}, p. 1}

The Google PlayStore on the other hand hosts Android application in \acs{APK} containers that are non encrypted and allow for decompilation back into the original source files. 
In order to automate the download process of \acs{APK} files to our local computer, we found a hidden Google \acs{API} that reveals access to the \acs{APK} files from the PlayStore. 
The \acs{API} can be queried by sending an Android device id along, effectively pretending to be a requesting Android device.
The result of the query is a binary \acs{APK} file.

\cite{Xu2015} provision a repository of apps listings that are extracted from the Google PlayStore within the categories "Health \& Fitness" and "Medical".
Due to the obstacles of gaining access to the Apple iOS binary files, we restrict the dataset to the available Android apps and conduct our automated privacy risk assessment on these apps.
The \cite{Xu2015} dataset contains 5379 Android apps. 
We exclude paid apps from further proceeding, since downloading paid apps would charge the credit card of the authors, since we use the same \acs{API} that the Google PlayStore itself uses to purchase apps from the store on Android devices. 
Downloading all 5379 apps would result in purchasing costs of 19,904.24 US-dollars. 
Therefore we reduce the dataset to the 3180 free apps, which is still 59.1\% of the  initial dataset. 
We will download as many apps of these 3180 as possible.
Potential limitations in downloading could arise from the fact that Google blocks requests on the API as soon as the system detects overly use or misuse. Downloading 3180 apps at a time will likely trigger these security mechanisms of Google, since a normal user could never download that many apps in the same timeframe from the PlayStore.

As soon as the \acs{APK} files are available offline, the decompiling phase of the study will begin.
Our decompiling process consists of four steps.

The first step is to recover a java archive (\acs{JAR}) file from the \acs{APK} file.
\acs{JAR} files contain a collection of .class files. 
These .class files hold Java bytecode that can be interpreted by the Java virtual machine \acs{JVM} at application runtime.\footnote{The previous two sentences follow \cite{Enck2011}, p. 2} 
In order to extract the Java bytecode .class files, we use the command line tool \textit{dex2jar}\footnote{https://github.com/pxb1988/dex2jar, visited 02/03/2016}. 
The abbreviation \acs{DEX} stands for \acl{DEX} and refers to the binary collection of compiled Java classes within the \acs{APK} file.\footnote{See \cite{xu2013techniques}, p. 6}

Step two includes the actual decompiling phase of the Java bytecode back into readable .java files. 
A .java file contains exactly one Java \textit{class} in humanly readable Java code. 
\cite{Enck2011} developed their own Java decompiling toolchain in order to assess security issues and used within their toolchain used a tool called \textit{Soot}.
\textit{Soot} optimizes the decompiled code to improve the readability by humans.
Aside from using \textit{Soot}, \cite{Enck2011} propose the idea to use different Android decompiler tools, such as \textit{JD} or \textit{Fernflower} in future research, since \textit{Soot} did not perform well in all cases.  \footnote{For the previous three sentences, see \cite{Enck2011}, p. 5}
We will use \textit{Fernflower} as the decompiling tool for our study, since it evidentially outperformed \textit{Soot} in a further evaluation by \cite{Enck2011}.\footnote{\cite{Enck2011}, p. 6}
The result of this second step is a directory full of .java files that represent the source code of an \acs{APK} app.

The decompiling process delivers source code files that lack any formatting.
For the case of manually validating the output of the automated privacy risk assessment we will have to take a look into the source code files. 
To make manual code inspections easier to read, a tool called \textit{astyle}\footnote{http://astyle.sourceforge.net/, visited 02/03/2016} will be used. 
\textit{astyle} sets appropriate levels on indenting to the source code.

In the fourth and last step of our decompilation process, a tool called \textit{apktool}\footnote{https://github.com/iBotPeaches/Apktool, visited 03/02/2016} is used to extract all resource files from the \acs{APK} file. Resource files could be images or XML files that are not compiled into application code.\footnote{See \cite{xu2013techniques}, p. 5}

% static code analysis %
\subsubsection{Static code analysis}
In order to analyse potential privacy risks, we are going to use a static code analysis tool.
This tool will scan and parse the Java source code files and make them computer readable.

\cite{Bruggemann2016} identified six potential privacy risk factors that a \mH app could pose and combined them into a privacy risk index formula. 
The six factors contain three binary factors.
The first binary factor is whether an app requires a login via username/email or a social media login service such as Facebook. 
The second binary factor is the question if the app uses secured \acs{HTTP} connections to the servers it is communicating too.
While the first ones can be assessed at a reasonable level of difficulty via static code analysis, it is challenging to do so for third binary factor: reasonableness of personal data collection. 
The reasonableness of personal data collection assessment in the study of \cite{Bruggemann2016} was based on usage observation of the app. This might not be feasible in a static code analysis.
The non-binary factors include the categories of personal data that users have to input into the \mH apps. Examples of personal data categories are: Medication intake, Symptoms, Vital values.
The last two factors express the target to which the personal data is likely to be sent. 
This is split in two factors, one for unspecific data targets, which refers to the usage of advertisement banner services or analytics tools within the app. 
The other data target factor tries to observe immediate data connections after input of personal data. 
\cite{Bruggemann2016} observed that personal data might be sent to a server of the app provider, advertisement or marketing companies, social media networks (such as Facebook) or to research projects.\footnote{This section follows \cite{Bruggemann2016}, p. 1-99}

Our study aims at identifying the privacy risk factors from \cite{Bruggemann2016} by scanning the source code of each app in our working dataset. 
% LOGIN %
In order to identify whether an app required the users to login, the source code will be scanned for text input fields that are labelled with the substrings "login", "register", "password". 
Additionally, the source code will be scanned for social network login buttons.
They are identified by the button name "com.facebook.login.widget.LoginButton" for Facebook login, "SignInButton" for Google login and "com.twitter.sdk.android.core.identity.TwitterLoginButton" for Twitter login functionality.
% SSL %
Android uses a \textit{RequestQueue} to dispatch HTTP requests from the main thread. 
We will scan the source code for requests that are added to the \textit{RequestQueue} and trace the url, that is the request target, back, until we can check if the URL contains the HTTPS prefix.
This indicates a secure connection.
% DATA TARGET %
The URL targets that requests are made to also indicate the personal data target factor.
Especially if variables that were assigned through user input fields can be traced until they might be sent out in a request.
% DATA CATEGORIES %
In order to identify the individual text fields that ask for user input, two source code scanning methods need to be used.
The Android \textit{EditText} classes can either be declared within the layout \acl{XML} (\acs{XML}) file or added via Java code during application runtime.
In both cases the label and ID properties of the \textit{EditText} instance can indicate the semantics of the personal data that is requested from the users.
As soon as we got an overview of the \textit{EditText} labels, we are going to cluster them into the personal data categories proposed by \cite{Bruggemann2016}.
At this point it would be possible to train a naive Bayes classifier, to judge the personal data categories from the individual data input text field labels.
% UNSPECIFIC DATA TARGETS %
To identify if analytics or advertisement services are used within the app, we can simply scan for the inclusion of corresponding libraries. For example the Google Analytics\footnote{https://www.google.com/analytics/, visited 02/05/2015} library is used within Android source code by including the package \textit{com.google.android.gms.analytics.GoogleAnalytics}.

After the implementation attempts of all privacy risk factors are completed

\subsection{Evaluation}

The evaluation phase starts with an overview of the degree of privacy risk assessment automation that has been accomplished. 
The evaluation will be based on the feasability and obstacles detected in implementing the automated privacy risk assessment.
The explored privacy risk factors will be combined into the privacy risk index weighted-sum equation, proposed by \cite{Bruggemann2016} and will be displayed within their user interface.\footnote{\cite{Bruggemann2016}, p. 99}
Using the \cite{Bruggemann2016} user interface allows the users to explore and compare \mH apps in a table view format. 
It can be used in addition to downloading apps from the Google PlayStore.

In order to further evaluate the automated privacy risk assessment, we will expose 15 potential users to the user interface and let them discover our detected privacy risks.
We will give an overview of the users options towards the presence of enhanced privacy risk information, that might change the users decision making process regarding the selection of \mH apps.

% STRUCTURE %
\section{Structure}

Es folgt eine Erläuterung der Gliederung der Bachelorarbeit. In Klammern steht jeweils der geschätzte bzw. anvisierte Umfang des jeweiligen Kapitels.
\newline\newline


\begin{longtable}{>{\bfseries}p{5.2cm} p{9.1cm}}
    \arrayrulecolor{lightgray}
    1 Introduction & The introduction provides an overview of the problem statement, the objectives, the methods used and the structure of the thesis.\\\hline
    
    1.1 Problem Statement & Description of the research cycle of the master thesis to further stress the practice problem and its relevance, as well as the research problem and its relevance.\\\hline
    
    1.2 Related Work & Overview of previous research and related work that has covered the topic of analysing \mH privacy risks or even using automated techniques on gathering privacy risk information\\\hline
    
    1.3 Objectives & This section describes the primary objective of the thesis and the subsequent secondary objectives, that we will aim at reaching.\\\hline
    
    1.4 Methods & An overview of the research approach of this master thesis that reflects the main part of the thesis.\\\hline
    
    1.5 Structure & The formal structure of the thesis to provide the reader with an  overview of the thesis.\\\hline\hline
    
    2 Automated Privacy Risk Assessment & This chapter describes the main implementation phase of the thesis.\\\hline
    
    2.1 Privacy Risk Factors & Introduction of the privacy risk factors identified by \cite{Bruggemann2016} and a further explanation on their relevance to \mH app assessments.\\\hline
    
    2.2 Implementation & Details on the implementation of the automated \mH privacy risk assessment tool.\\\hline
    
    2.2.1 Download Phase & Description of the \acs{APK} file discovery and download phase of the tool. While free Android apps are available for everybody with an Android smartphone, we want to feed \mH apps into our automated system and therefore need to download the \acs{APK} files automatically.\\\hline
    
    2.2.2 Decompilation Phase & This section provides information on the decompilation phase of the \acs{APK} files and the methods used to regain the source code of Android apps. This is a crucial step, since the source code is our main and only resource to perform the static code analysis on, in chapter 2.2.3.\\\hline
    
    2.2.3 Static Code Analysis Phase & Information on the different approaches to gather information on the individual privacy risk factors, explained in chapter 2.1. We will try to identify via a static code analysis, if the \mH app requires a login to tailor the user experience or not. Furthermore we want to find out if personal health data is collected and if so, what kind of data. Via source code analysis we aim at identifying the targets, where data is sent and if advertisement or click-analytics services are used.\\\hline
    
    2.3 Results & Explaining the outcome of the implementation step. How many apps could be automatically assessed? How many factors could be automatically identified? Was it possible to compute information on all of the privacy risk factors from chapter 2.1?\\\hline\hline
    
    3 Evaluation & Evaluating the outcomes of this thesis by critically appreciating the results of the implementation and the opinions of potential users.\\\hline
    
    3.1 Evaluation of Implementation & Information on the feasibility of implementing an automated \mH privacy risk assessment tool, the challenges and obstacles. \\\hline
    
    3.2 Overview of Users' Opinions & Further evaluation of the automated privacy risk assessment tool is given by presenting an overview of the users' options on the tool. We will expose 15 users with our novel tool and share their option on the implications this tool has on \mH app decision making.\\\hline\hline

    4 Conclusion & A critical reflection on the thesis. Are all the objectives reached and are the methods used coherent? \\\hline
    
    4.1 Limitations & Explanations in what way the research approach and execution was limited or constrained during this thesis.\\\hline
    
    4.2 Future Research & This section will provide hints to future researchers on how to continue or extend the current study in this thesis and further develop the implemented tool and its implications.\\\hline
\end{longtable}


% EXPECTED RESULTS %
\section{Expected Results}

As a result of this master thesis, we expect the implementation process of the automated privacy risk assessment to be at least partially feasible and implemented. 
Automating the downloading process of \acs{APK} app files from the Google PlayStore is possible to a certain amount, and will be provided.
The decompilation process is set to gain at least a 94 to 98\% code recovery rate.\footnote{\cite{Enck2011}, p. 5-6} 
Therefore we expect the majority of \acs{APK} files to be decompilable.
We expect the static code analysis for privacy risk factors to be success for the majority factors and will provide insights into the possible degree of detail.

Another expected result is an overview of the users' options on the usage of the tool. 
Depending on the implementation success it will reveal to be either useful or rather not useful to the users decision making process regarding \mH apps.

% PROBLEMS %
\section{Problems}
So far there are no open questions or problems. Though, a problem could arise from the fact that the core of this master thesis relies on a undocumented Google \acs{API} for downloading the \acs{APK} files of the apps. 
If this \acs{API} is shut down or somehow secured from open usage, it would not be as easy to gather the needed \acs{APK} files for the \sca as it currently is.
It might be possible to circumvent the usage of undocumented Google \acs{API}s by downloading the \acs{APK} files manually or semi-automated on an Android smartphone. 
This will be a fallback solution.
%After downloading the first 1081 apps via the undocumented Google API function, my Google PlayStore account was suspended and I was automatically logged out of my Google account in the PlayStore app on my tablet. 
%It might be possible to circumvent this by creating another Google account and using that one on my tablet. 
%The tablet is important, since the undocumented Google API is queried with the unique Android ID of the tablet.
%As long as the suspension is linked to my Google account and not the Android ID, a realistic chance exists to download more \acs{APK} files.

% --------------------
% REFERENCES
% --------------------
\newpage
\printbibliography[title={References}]
\addcontentsline{toc}{section}{References}
\end{document}