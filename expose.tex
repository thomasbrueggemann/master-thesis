%
% Expose: Master Thesis
% Thomas Brüggemann
%

% -----------
% 1. Präambel
% -----------

% Allgemeine Einstellungen
% ------------------------
\documentclass[
	a4paper,
	oneside,
	12pt,
	liststotocnumbered
]{article}
\usepackage{times}            % Times New Roman

\usepackage[utf8]{inputenc}   % utf-8
\usepackage[english]{babel}    % english hyphenation
\selectlanguage{english}       % english titles
\usepackage{nicefrac} 
\usepackage{longtable}

% Titel-Font-Größen
\usepackage{titlesec}
\titleformat{\section}{\bfseries}{\thesection.}{12pt}{}
\titleformat{\subsection}{\bfseries}{\thesubsection }{12pt}{}

% Seitenränder
\usepackage[
    top=2.5cm, 
    bottom=2.5cm, 
    left=5cm, 
    right=1cm
]{geometry} 

% Fussnoten
\usepackage[hang,flushmargin]{footmisc}    
\renewcommand*{\footnotelayout}{\footnotesize} % size of text
\renewcommand{\footnotemargin}{2.2em}          % margin between text and number
\setlength{\footnotesep}{1.3em}                % space between footnotes
\setlength{\skip\footins}{2.5em}               % space between text & footnotes
\usepackage{savefnmark}

% Abkürzungen
\usepackage[printonlyused]{acronym}    
\renewcommand{\bflabel}[1]{{#1\hfill}}

% Seitennummerierung oben
\usepackage{scrpage2} 
\usepackage[dvips]{color}
\clearscrheadfoot 
\chead[\pagemark]{\textcolor[gray]{0.5}{\pagemark}} 
\pagestyle{scrheadings}

% TOC, LOF, FIG Styles
\usepackage{tocloft, titletoc}  
\setlength{\cftaftertoctitleskip}{0em}
\renewcommand{\cftloftitlefont}{\bfseries}
%\renewcommand{\cftfigfont}{\bfseries}
\renewcommand{\cfttoctitlefont}{\bfseries}
\renewcommand{\cftlottitlefont}{\bfseries}
\titlecontents{section}     % set formatting for \section 
[2.3em]                     % adjust left margin
{\vspace{0.5em}}            % font formatting
{\hspace{-1.8em}.\contentslabel{0.7em}\hspace{1em}} % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}

\titlecontents{subsection}  % set formatting for \subsection 
[3em]                       % adjust left margin
{\vspace{0.5em}}            % font formatting
{\contentslabel{2.3em}}     % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}

\titlecontents{subsubsection}  % set formatting for \subsubsection 
[4.2em]                       % adjust left margin
{\vspace{0.5em}}            % font formatting
{\contentslabel{2.3em}}     % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}

\titlecontents{figure}      % set formatting for \subsection 
[2.3em]                     % adjust left margin
{\vspace{0.5em}}            % font formatting
{\contentslabel{2.3em}}     % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}

\titlecontents{table}       % set formatting for \subsection 
[3.4em]                     % adjust left margin
{\vspace{0.5em}}            % font formatting
{:\hspace*{0.9em}\contentslabel{4.5em}}     % section label and offset
{\hspace*{-2.3em}}
{\titlerule*[1mm]{.}\contentspage}


% Literaturverzeichnis
\usepackage[
    bibstyle=authortitle,
    citestyle=authoryear,
    backend=biber,
    isbn=false,
    url=false,
    doi=false,
    maxcitenames=3,
    maxbibnames=30
]{biblatex}
\addbibresource{library.bib}
\let\cite\textcite

\usepackage{caption}
\usepackage{chngcntr}

% Tabellenpackete
\usepackage{array}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{setspace}
\counterwithin{table}{section}
\usepackage{multirow}
\usepackage{colortbl}

% Grafiken anzeigen
\usepackage[pdftex]{graphicx}
\graphicspath{{figures}}
\counterwithin{figure}{section}
\usepackage[absolute,overlay]{textpos}

\begin{document}

% Renews
\renewcommand{\figurename}{Figure}
\renewcommand{\tablename}{Table}
\renewcommand\thefigure{\arabic{section}-\arabic{figure}}
\renewcommand\thetable{Tab. \arabic{section}-\arabic{table}}
\newcommand{\todo}[1]{\textbf{\textsc{\textcolor{red}{TODO: #1}}}}

% Variables
\newcommand{\mH}{mHealth }
\newcommand{\ap}{app provider }
\newcommand{\pp}{privacy policy }
\newcommand{\pps}{privacy policies }
\newcommand{\sca}{static code analysis }
\newcommand{\Sca}{Static code analysis }
\newcommand{\pra}{information privacy risk assessment }
\newcommand{\prfs}{information privacy risk factors }
\newcommand{\ipr}{information privacy risks }
\newcommand{\iprfs}{information privacy risk factors }
\newcommand{\iprs}{information privacy risk score }
\newcommand{\gui}{graphical user interface }
\newcommand{\ipp}{information privacy practices }

\pagenumbering{Roman}

% Deckblatt
% ---------
\include{titlepages/cover}

% Inhaltsverzeichnis anzeigen
% ---------------------------
\tocloftpagestyle{scrheadings}
\tableofcontents
\newpage

% Abkürzungsverzeichnis
\section*{Index of Abbreviations}
\addcontentsline{toc}{section}{Index of Abbreviations}
\begin{acronym}[TTTTTTTTTTTTTTTTTTTT]
	\acro{API}{Application Programming Interface}
	\acro{APK}{Android Application Package}
	\acro{DEX}{Dalvik Executable}
	\acro{DRM}{Digital Rights Management}
	\acro{HTTP}{Hypertext Transfer Protocol}
	\acro{JAR}{Java Archive}
	\acro{JVM}{Java Virtual Machine}
    \acro{mHealth}{Mobile Health}
    \acro{XML}{Extensible Markup Language}
\end{acronym}
\newpage

\normalsize
\setstretch{1,5}
\pagenumbering{arabic}

% PROBLEM STATEMENT %
\section{Problem Statement}
The market for mobile phone and tablet applications (apps) has grown extensively since recent years.\footnote{See for this and the following sentence \cite{Enck2011}, p. 1.}
It is increasingly easier for companies or even single developers to create unique apps that reach millions of users around the planet via digital app stores.
This market growth affected mobile health (\acs{mHealth}) apps as well. 
More and more \mH apps are available that support the users in resolving their health-related issues and that try to remedy health-related information deficiencies. 

But receiving personal health-related information yields information privacy risks to users.
Users are asked to expose personal health-related information, e.g. information on disease symptoms or medical appointments in order to receive a tailored app that fits their needs.\footnote{See \cite{Chen2012}, p. 2.}
It remains however unclear how and where the vulnerable user information is sent, processed and stored.\footnote{See \cite{He2014}, p. 652.}

The information about these privacy related practices of app providers and their offered apps should be stated in the privacy policy document provided by the app provider.\footnote{This paragraph follows \cite{Dehling2014}, p. 11.}
Processing these \pps requires a higher level of education and time to read through large bodies of text, in order to find the relevant information. 
Additionally, the important information is hidden in legal language or is  insufficiently addressed, if at all.\footnote{See \cite{Pollach2007}, p. 104.}
Aside from data usage beyond the control of the users, it is also challenging to assess what kind of private information an app asks for, prior to the app usage. 
Users have to download the apps of interest and try them out, before it becomes clear what health-related information is processed by the app and in which  way. 
This leads to low comparability between apps. 
When users are looking for specific functionality in an \mH app, it is challenging to find the app that offers the desired functionality at an acceptable information privacy risk. 
Even if users would pursue the task of finding and comparing \mH apps of similar functionality, the high volume of apps available in the app stores\footnote{See \cite{Enck2011}, p. 1.} makes it laborious to review all of them by hand.
One way to assess \ipr of the large amount of \mH apps is to automate the review process of each individual app. 
The assessment automation can be done by downloading and analyzing the source code of each app and by tracing data leaks. 
\Sca is used in the field of informatics to analyze application source code and detect faults or vulnerabilities.\footnote{See \cite{Baca2008}, p. 79.} 
It is yet unclear how and to what degree the concepts of \sca and \pra can be combined in order to automate app assessment.
A \sca could, in theory, be used to automatically assess some of the \ipr that \mH apps pose.
Previous research has not shown how and to what degree the combination of \sca and \ipr assessment is feasible in the field of \mH app \pra and therefore the aim of this study is to explore the possibilities of static code analysis for information privacy risk assessment. 
This leads to the research question: How and to what degree can the \ipr of mHealth apps be automatically assessed?
The 'degree' refers to the amount and the level of detail that \iprfs can be automatically assessed.

The automated process furthermore can help to drastically reduce the effort of reviewing each individual app and can enhance the information experience users receive while looking for mHealth apps.Additionally, it exposes new possibilities for research in the \ipr area. 
The research could be conducted on providing solutions and best practices for further enhancing the \ipr communication of apps.

% RELATED WORK %
\section{Related Work}
\mH apps have been examined in various research studies that aim at providing insights for developers as well as users into how private information is processed.
Privacy issues are the most impactful user complaint while using mobile apps.\footnote{See \cite{Khalid2015}, p. 5.}
This encourages research to address information privacy risks.

Research focus has been put on the technical side of information privacy breach. 
It has been analyzed, to what degree the data storage in internal Android log files or on the memory card within a phone or tablet poses a threat to users information privacy.\footnote{For the previous two sentences, see \cite{He2014}, p. 645-646.}
Technical evaluation of mobile apps even goes further into the topics of decompilation to analyze device identification or geolocation data leaks.\footnote{See \cite{Mcclurg2012}, p. 1, 5., \cite{Enck2011}, p. 1. and \cite{Mitchell2013}, p.6-7.}
Decompilation reveals to be a feasible assessment technique for \ipr and data leaks.

In informatics and software development contexts, \sca has been used to analyze source code and provide feedback on coding styles to the users  while programming or "to find defects in programs"\footnote{\cite{Bardas2010}, p. 1.}.
\Sca provides a fast way to analyze source code\footnote{See \cite{Bardas2010}, p. 5.}, which makes it suitable to automate the assessment of large datasets.
A further benefit of using \sca to retrieve information from software is that the software does not need to be executed during the analyzation process.
This additionally supports the development of fast performing assessment tools that are suitable for application on large datasets of source code since there is no need to wait for the application runtime to execute the software.

Our study will use the benefits of \sca and apply them to the assessment of \mH information privacy risks.
It is unclear if \sca is a viable tool to analyze and identify information privacy risk factors.
We will use the comprehensive privacy-risk-relevant information privacy practices that \cite{Dehling2016} identified\footnote{See \cite{Dehling2016}, p. 8-17.} and try to implement \sca strategies to identify those risks automatically.
This will be a vital addition to current research, since there is yet no holistic approach to apply \sca to \ipr detection that takes an ample amount of \iprfs into account.

% OBJECTIVES %
\section{Objectives}

The main objective of this study is to ascertain how and to what degree the assessment of \iprfs for \mH apps can be automated.
In order to reach this objective, the following sub-objectives have to be met.

The first sub-objective is to extract \iprfs from the \ipp that \cite{Dehling2016} identified and that are relevant for automated information privacy risk assessment.
As a second sub-objective we will develop strategies to identify the \iprfs within the source code of \mH apps via static code analysis.
This is necessary since it is yet unclear how and to what degree the \sca can help to identify \iprfs of \mH apps. 
Finally we will evaluate how well the automated \pra tool can identify \iprfs in comparison to two human reviewers.
In order to fully ascertain the degree \sca can identify information privacy risk factors, a manual review of the results of the \sca is necessary.

% DEFINITIONS %
\section{Definitions}
Certain terms are used in the remainder of this thesis that have to be defined:

% Decompilation %
\subsection{Decompilation}

Compilers transfer human readable programming code into machine code and therefore help humans write software applications in understandable text form.\footnote{This section follows \cite{nolan2012decompiling}, p. 1-2.}
Decompilers retrieve the human readable programming code back from the compiled machine code. 
The compilation process of an application is non-reversible. Therefore, decompiling is a reverse engineering technique that outputs source code, similar to the original source code of the application, but with the same functionality.  

% Mobile health apps
\subsection{Mobile Health Apps}

Mobile health (\acs{mHealth}) apps are smartphone or tablet applications that support users by enabling them to gather health-related information and support the consumer in dealing with medical or health-related issues.\footnote{See \cite{Dehling2015b}, p. 1.}

% Information Privacy Risk Factor %
\subsection{Information Privacy Risk Factor}
An information privacy risk factor is an indicator of a potential threat or a circumstance that increases the risk of an information privacy breach.
Information privacy is defined as the fact that people are able to control if, how and where information and knowledge about themselves is gathered, stored and processed \footnote{See \cite{Fischer1998}, p. 421-422.}.
Additionally society and social structure must establish an information regulation architecture that allows people to enforce their information privacy rights \footnote{\cite{Solove2002}, p. 1115.}.
Threats to information privacy in digital services can happen at application level (e.g. by sharing users' personal information with third-parties), as well as at communication level (e.g. by using an unencrypted data connection).\footnote{See \cite{Fischer1998}, p. 423-427.}
% Static code analysis %
\subsection{Static Code Analysis}

Static code analysis refers to the analysis of application source code without actually executing the application. 
This technique is widely used to detect vulnerabilities or to validate the source code during development in the source code editor software.\footnote{See \cite{Bardas2010}, p. 2-3.}

% METHODS %
\section{Methods}

% Automating the information privacy risk assessment %
\subsection{Automating the Information Privacy Risk Assessment}

% android decompilation
\subsubsection{Android Decompilation}

In order to automate the \pra of \mH apps via static code analysis, it is necessary to gain access to the source code of the apps. 
For this study we focus on Android apps, since Apple's digital rights management (\acs{DRM}) system encrypts the binary app file in a way that makes recovering the source code difficult. 
There are existing approaches to decompiling the Apple app binary back into its source code.
These approaches involve unlocking and jailbreaking\footnote{Jailbreaking refers to the action of unlocking the iOS device firmware to gain unrestricted access to the bootloader. See \cite{Kweller2010}, p. 1.}
an Apple iPhone or iPad, which is a violation of the Apple terms of service and therefore forbidden.\footnote{See \cite{Kweller2010}, p. 1.}

The Google PlayStore on the other hand hosts Android applications in \acs{APK} containers that are non-encrypted and allow for decompilation back into the original source files. 
In order to automate the download process of \acs{APK} files, we make use of an undocumented Google \acs{API} that reveals access to the \acs{APK} files from the Google PlayStore. 
The \acs{API} can be queried by sending an Android device id, pretending to be a requesting Android device. It is used by the Google PlayStore internally and the result of the query is the binary \acs{APK} file.

To get an overview of the APK files available on the Google PlayStore, we use the repository of app listings by \cite{Xu2015} that was extracted from the Google PlayStore from the categories 'Health \& Fitness' and 'Medical'.
Due to the obstacles of gaining access to the Apple iOS binary files, we restrict the dataset to the available Android apps and conduct our automated \pra on these apps.
The \cite{Xu2015} dataset contains 5,379 Android apps. 
We exclude paid apps from our study. Downloading paid apps would charge the credit card of the authors since we use the same \acs{API} that the Google PlayStore itself uses to purchase apps on Android devices. 
Downloading all 2,199 paid apps would result in a purchase value of 19,904.24 US-dollars. 
Therefore, we reduce the dataset to the 3,180 free apps, which is still 59.1\% of the apps from the initial dataset. 
We will download as many of these 3,180 apps as possible.
Attempting to download 3,180 apps in a short period of time triggers Googles security mechanisms, since a normal user could not download that many apps in the same timeframe from the PlayStore.
We will apply a careful downloading technique and allow for pauses in between app downloads to not over-use the Google API.

As soon as the \acs{APK} files are available offline, the decompiling phase of the study will begin.
Our decompiling process consists of four steps.

The first step is to recover a java archive (\acs{JAR}) file from the \acs{APK} file.
\acs{JAR} files contain a collection of .class files. 
These .class files hold Java bytecode that can be interpreted by the Java virtual machine (\acs{JVM}) at application runtime.\footnote{The previous two sentences follow \cite{Enck2011}, p. 2.} 
In order to extract the Java bytecode .class files, we use the command line tool \textit{dex2jar}\footnote{\cite{Pan2010}.}. 
The abbreviation \acs{DEX} stands for \acl{DEX} and refers to the binary collection of compiled Java classes within the \acs{APK} package file.\footnote{See \cite{xu2013}, p. 6.}.

Step two includes the actual decompiling phase of the Java bytecode back into .java files. 
A .java file contains exactly one Java \textit{class} in human-readable Java code. 
\cite{Enck2011} developed their own Java decompiling toolchain in order to assess security issues of \mH apps, since \textit{dex2jar} was not functioning at the time they conducted their study.\footnote{See \cite{Enck2011}, p. 16.}
Within their toolchain, they used a tool called \textit{Soot}.
\textit{Soot} optimizes the decompiled code to improve the readability by humans.
%Aside from using \textit{Soot}, \cite{Enck2011} propose the idea to use different Android decompiler tools, such as \textit{JD} or \textit{FernFlower} in future research, since \textit{Soot} did not perform well in all cases. \footnote{For the previous three sentences, see \cite{Enck2011}, p. 5.}
We will use \textit{FernFlower} as the decompiling tool for our study, since it evidentially outperformed \textit{Soot} in a further evaluation by \cite{Enck2011}.\footnote{See \cite{Enck2011}, p. 6.}
The result of this second step will be a directory full of .java files that represents the source code of the \acs{APK} apps.

The decompiling process delivers source code files that lack any formatting.
For the case of manually validating the output of the automated information privacy risk assessment, we will have to take a look into the source code files. 
To make manual code inspections easier to read, a tool called \textit{astyle}\footnote{\cite{Davidson2006}.} will be used. 
\textit{astyle} sets appropriate levels on indenting to the source code, to improve the reading experience.

In the last step of our decompilation process, a tool called \textit{apktool}\footnote{\cite{Tumbleson2010}.} is used to extract all resource files from the \acs{APK} file. Resource files could be images or XML files that are not compiled into application code.\footnote{See \cite{xu2013}, p. 5.}
The XML files are of interest for the automated information privacy risk assessment, because Android text input controls can be defined in an external XML file, rather than in the source code itself.

% static code analysis %
\subsubsection{Static Code Analysis}
In order to analyze potential information privacy risks, we are going to use a static code analysis tool.
This tool will scan and parse the Java source code files and make them processable for further analysis.
The \sca tool will not be able to identify new \prfs by itself, but rather has to be individually programmed to scan the source code for privacy risk factors.

\cite{Dehling2016} compiled a list of \ipp that current research literature proposes to be contained in privacy policies and implemented by app providers.\footnote{This section follows \cite{Dehling2016}, p. 8-17.}
The \ipp are listed hierarchically in the categories 'data handling', 'information collection', 'meta information', 'privacy controls' and 'rationale' of information privacy practices.
We argue that, if literature proposes to include certain \ipp in privacy policies, these \ipp might indicate an information privacy risk.
While not all of the risk-bearing \cite{Dehling2016} \ipp will be eligible for automated static code analysis, we will classify the relevant practices and include them into our \sca assessment.

To name one example strategy of identifying a \ipp that bears an information privacy risk, we will take a look at 'SharingWithAnalystContent'.
'SharingWithAnalystContent' is located in the \ipp hierarchy under 'Content', 'InformationSharingContent' and expresses the information privacy risk of personal user data being shared with analytic software services, e.g. click tracking services or app usage services.
To identify such an information privacy risk within the source code of an app, we will compile a list of common Android analytics libraries and create a \sca strategy to scan our app dataset source codes for these libraries.
For each individual risk-assessment strategy we will seek for patterns that can identify even more features than than we originally searched for.
In the example of 'SharingWithAnalystContent' this means seeking for a pattern in the source code that can identify Android analytics libraries beyond the predefined list of common libraries.
A pattern for analytics libraries could be based on the naming of libraries, e.g. libraries that contain the phrase "analytics". 
Another pattern could be based on common method names other analytics libraries used, e.g. '.track()' or '.trackView()'.

\subsection{Evaluation}

First, we want to evaluate the degree of \pra automation that has been accomplished. 
The evaluation will be based on the feasibility and obstacles detected in implementing the automated information privacy risk assessment and a performance comparison against human assessment.
We will outline which \iprfs can and can not be detected automatically, as well as the reasons for this.
Furthermore, we will evaluate for which \prfs the automated \sca is superior to using manual assessment techniques.

For evaluation of the accuracy of automated \sca of the apps, we will look at a selection of 15 apps in greater detail and manually review the results of the static code analysis.
The manual assessment of the test app sample will be conducted by two researchers individually and the results will be presented.
We will assess if the \sca managed to identify all of the prevailing \ipr within the app and if not, what the reasons for failure are.
This will give a sense of how well the \sca performs in identifying the information privacy risks in comparison to a human reviewer.

% STRUCTURE %
\section{Structure}

In this section we would like to introduce the structure of the final thesis chapters.
\newline
\begin{longtable}{>{\bfseries}p{5.2cm} p{9.1cm}}
    \arrayrulecolor{lightgray}
    1 Introduction & The introduction provides an overview of the problem statement, the objectives, the methods used and the structure of the thesis.\\\hline
    
    1.1 Problem Statement & Description of the research cycle of the master thesis to further stress the practice problem and its relevance, as well as the research problem and its relevance.\\\hline
    
    1.2 Objectives & This section describes the primary objective of the thesis and the subsequent secondary objectives, that we hope to reach.\\\hline
    
    1.3 Structure & The formal structure of the thesis, used to provide the reader with an overview of the thesis.\\\hline\hline
    
    2 Combining Source Code Analysis with Information Privacy Risk Assessment & Overview of previous research and related work that has covered the topic of analyzing \mH information privacy risks or using automated techniques on gathering privacy risk information as well as the usage of static code analysis.\\\hline
    
    2.1 Information Privacy Risk Assessment & Overview of literature that already covered the topics of \ipr assessent.\\\hline
    
    2.2 Static Code Analysis & Overview of literature concerning static code analysis in use as a code analysis tool in the field of informatics.\\\hline
        
    2.3 Relevant Information Privacy Risk Factors & Introducing the \cite{Dehling2016} \ipp and filtering out the ones that pose an information privacy risk.\\\hline
    
    3 Implementation and Evaluation of an Automated Information Privacy Risk Assessment Tool & This chapter describes the main implementation phase of the automated \pra tool.\\\hline
    
    3.1 Implementation of an Automated Information Privacy Risk Assessment Tool & Details on the implementation of the automated \mH \pra tool itself.\\\hline
    
    3.1.1 Download Phase & Description of the \acs{APK} file discovery and download phase of the tool. Free Android apps are available for everybody with an Android smartphone. We want to feed \mH apps into our automated assessment system and therefore need to download the \acs{APK} files automatically.\\\hline
    
    3.1.2 Decompilation Phase & This section provides information on the decompilation of the \acs{APK} files and the methods used to regain the source code of Android apps. This is a crucial step, since the source code is our main resource to perform the static code analysis on.\\\hline
    
    3.1.3 Static Code Analysis Phase & Information on the different approaches to gather information on individual information privacy risk factors, explained in chapter 3.1. We will try to identify via the static code analysis, if the \mH app requires a login to tailor the user experience or not. Furthermore, we want to find out if personal health data is collected and if so, what kind of data. Via source code analysis we aim at identifying the targets, where data is sent and if advertisement or click-analytics services are used.\\\hline
    
    3.2 Evaluation of an Automated Information Privacy Risk Assessment Tool & Information on how we manually review the outcome of the \sca by checking a random set of apps from the initial dataset.\\\hline\hline
    
    4 Feasibility of Automated Information Privacy Risk Assessment &  How many apps could be automatically assessed? How many factors could be automatically identified? Was it possible to compute information on all of the \iprfs from chapter 2.3?\\\hline\hline
    
    4.1 The Automated Information Privacy Risk Assessment of Free Android \mH Apps & Explaining the outcome of the implementation step. \\\hline
    
    4.1.1 Download Phase & Results on how many \mH apps could be downloaded and how the download phase went. \\\hline
    
    4.1.2 Decompilation Phase & Results on how many \mH could be decompiled and at what degree of quality.\\\hline
    
    4.1.3 Static Code Analysis Phase & Results on the outcome of the \sca\\\hline
    
    4.2 Evaluation of the Automated Information Privacy Risk Assessment Tool & Results of how well the automated \sca performed in identifying \iprfs by manually surveying a set of apps and comparing the \iprfs to the \sca results.\\\hline\hline

    5 Discussion &  \\\hline
    
    5.1 Principle Findings & Information on the feasibility of implementing an automated \mH \pra tool, the challenges and obstacles. \\\hline
    
    5.2 Contributions & Outlining the contributions to research and practice this thesis has. \\\hline
    
    5.3 Limitations & Explanations in what way the research approach and execution was limited or constrained during this thesis.\\\hline
    
    5.4 Future Research & This section will provide hints to future researchers on how to continue or extend the current study in this thesis and further develop the implemented tool and its implications.\\\hline
    
    5.5 Conclusion & A critical reflection on the thesis. Were all the objectives reached and are the methods used coherent? \\\hline
\end{longtable}


% EXPECTED RESULTS %
\section{Expected Results}
The results of this master thesis will be the implementation of the automated \pra tool.
Part of the expected results will be the answer to the question, if \sca is a viable approach to assess \iprfs of \mH apps.

We expect the implementation process of the automated \pra to be at least partially feasible and implemented. 
Automating the downloading process of \acs{APK} app files from the Google PlayStore is possible to a certain extent, and will be provided.
The decompilation process is expected to gain at least a code recovery rate of above 90\%.\footnote{See \cite{Enck2011}, p. 5-6.} 
Therefore, we expect the majority of \acs{APK} files to be assessable.
We expect the static code analysis for \iprfs to be successful for the majority of factors and will provide insights into the possible degree of detail.

% PROBLEMS %
\section{Problems}
So far, there are no problems.

% --------------------
% REFERENCES
% --------------------
\newpage
\printbibliography[title={References}]
\addcontentsline{toc}{section}{References}
\end{document}