\section{Implementation and Evaluation of an Automated Information Privacy Risk Assessment Tool}

% Implementation of an Automated Information Privacy Risk Assessment Tool
\subsection{Implementation of an Automated Information Privacy Risk Assessment Tool}

Our implementation of an \aiprat is structured in three phases.
In the first phase, Android APK files need to be downloaded to acquire the foundation of a static code analysis: the source code.
While APK files are binary representations of source code, it is necessary, in a second phase, to decompile to binary code back into actual source files.
The third phase is the analysis phase, where the information privacy risk assessment takes place.

\begin{figure}[h]
	\label{fig:implementationPhases}
	\centering
	\includegraphics[keepaspectratio=true,width=400pt]{figures/ImplementationFlow.png}
	\caption{Diagram of implementation phases of the \aiprat over time.}
\end{figure}

Figure 3-1 shows the implementation phases over time including the tools used within each phase. 
The tools will be described in greater detail within the following chapters.

% Download Phase
\subsubsection{Download Phase}

The download phase is the first of the three implementation phases and comprises the acquisition of Android APK files. 
The APK files hold the necessary Java source code that we will perform the \sca on.
Since this thesis emphases on Android mHealth apps, we used the repository database of \cite{Xu2015} as our main app data source.\footnote{This paragraph follows \cite{Xu2015}.}
\cite{Xu2015} list mHealth apps from the Apple AppStore\footnote{\url{https://itunes.apple.com}, visited 07/13/16} and Android PlayStore\footnote{\url{https://play.google.com}, visited 07/13/16} and update their repository quarterly by scraping the app stores.
The list contains information for example on the app's identifier, category in the app stores, description, email address of the developer, price and the user rating of the app.

We used the repository database to loop over the available mHealth app listings and included only the apps that were available for free, indicated by a price of \$0.00.
As soon as the package name of an app is gathered, the download of the \acs{APK} file can begin. 
While there is no official source to download \acs{APK} files for Android apps, a multitude of websites exist that host copies of \acs{APK} files to download for free.
Unfortunately, all of these websites implement mechanisms that make it impossible to browse and download the APK files programatically within a download script.
Instead, we used a open source Python implementation of an undocumented Google PlayStore \acs{API}.\footnote{\raggedright\url{https://web.archive.org/web/20140920061441/https://github.com/egirault/googleplay-api}, visited 05/12/16.} 
The undocumented part of the Google API allows users to download APK files.
Even though the project has not been maintained for four years, the software is still in working order.
The Python script authenticates to the Google API via the hardware ID of an Android smartphone or tablet and pretends to request data from this smartphone or tablet, even though the requests are sent from a desktop computer.
We used a real Android tablet to detect its hardware ID and authenticate the Google API requests with this hardware ID.
The main issue that has to be taken care of during the download phase is not to run into Google API limitations. 
Google allows an API user to only request a certain amount requests per time unit. 
After this limit is exceeded, the requests will just return a HTTP error code and no APK file will be downloaded.
In order to work around this circumstance, we ran our download script multiple times, always until the Google API returns error codes. 
We then waited a couple of hours and tried the download script again, which would pick up the download process where it had stopped on the last run.

% Decompilation Phase
\subsubsection{Decompilation Phase}

In order to decompile the amount of APK files available, it is necessary to automate the process. 
The automation script\footnote{\raggedright \url{https://github.com/thomasbrueggemann/AIPRAT/blob/master/decompile/decompile.sh}, visited 05/17/16.} uses a chain of tools to gather access to the source code files from an APK file.
The tools used to decompile the APK files follow closely the tools described and used by \cite{Enck2011}.\footnote{See \cite{Enck2011}, p. 5.}

In a first step, we use the tool \textit{dex2jar} to extract the \acs{JAR} file from the APK file.
The JAR file contains the java bytecode representations of the app which is just one part of the contents of an \acs{APK} file.
The next step is to extract resource files, such as the \textit{Android Manifest} file from the APK file.
The \textit{Android Manifest} contains meta information about the app in a structured XML format.\footnote{See for this and the next sentence \cite{xu2013}, p. 7 and \cite{Shabtai2010}, p. 331.}
The meta information include the package name of the app, the permissions the app requests, for example camera usage, internet access or geolocation usage.
The \textit{Android Manifest} file is therefore an important indicator at a high level view on activities within a given app.
In order to extract the \textit{Android Manifest} file from the APK file along with other resources such as images, icons, xml files or other files used within the app, we use the \textit{apktool}\footnote{\url{https://web.archive.org/web/20160617041519/http://ibotpeaches.github.io/Apktool/}, visited 06/17/16.}.
\textit{apktool} is a frequently updated Android reverse engineering tool that is used to extract resources from APK files.
Another important part of the extraction of resource files is retrieving the layout and localization files.
These files include information on the user interface components used within the app as well as text content for labels and text fields.
The text content will be used to train machine learning algorithms to classify features of the app, further described in the analysis phase section below.

At the core of the decompilation process is the usage of \textit{fernflower}\footnote{\url{https://web.archive.org/web/20150808204302/https://github.com/fesh0r/fernflower}, visited 05/24/16.}.
\textit{fernflower} is the recommended java decompiler by \cite{Enck2011}. 
They used the tool to decompile a test sample of apps and gained a significantly higher code recovery rate than by using other decompiling tools.\footnote{See \cite{Enck2011}, p. 6.}
An obstacle in decompiling java source code is obfuscation. 
Java developers can make use of a security feature called obfuscation that aims at hiding away the logic of java classes by renaming classes, variables and method names and disassembling the code into pieces that are difficult to read for an human interpreter.
The idea is to make it more difficult to retrieve and make sense of the original source code by decompiling the byte code.
\textit{fernflower} uses a renaming approach by assigning every obfuscated class with a new naming pattern. 
Member variables and methods will be automatically renamed and therefore provide an easier and more unique way of reading the source code.
Optionally the decompilation process can use an automatic code formatting tool called \textit{astyle}\footnote{\url{https://web.archive.org/web/20160422015538/http://astyle.sourceforge.net/}, visited 05/25/16.} to format the source code.
This helps humans to read the source code files more easily, since the formatting and indentation of all source code files is identical and therefore very structured.
Formatting the source code will help in the evaluation phase of this thesis to support the manual inspection the source code for \ipr by human researchers.

The expected result of the decompilation phase is a directory named after the package name of a given app that contains the resource files, including the \textit{Android Manifest} and the decompiled source code of the app.
The decompilation will be performed in order of file size.
The smaller the APK file the earlier it will decompiled.
This is due the fact that only APK files to a certain size can be analysed by the dataflow analysis tool, described in section \ref{sssec:SCAP}.

% Static Code Analysis Phase
\subsubsection{Static Code Analysis Phase} \label{sssec:SCAP}

The \sca phase is the main analysis phase of the thesis and uses the output of the previous decompilation phase to perform the static code analysis.
The \sca tool is implemented as a Java software project, since the used analysis libraries are implemented in Java and Android source code is written in Java too.
The output of the \sca Java project is an executable Java archive file called \textit{AIPRAT.jar} that can be executed in the command line terminal.
In order for \textit{AIPRAT.jar} to perform the \sca on APK files, two preparation steps are required.

The first preparation step is to run an Android data flow analysis tool over the APK files that extract potential data flows.
The data flow analysis is achieved with an open source tool called \textit{FlowDroid}, introduced by \cite{Arzt2014}.\footnote{See \cite{Arzt2014}, p. 259-269.}
\textit{FlowDroid} extends the Java optimization framework \textit{Soot}, which was already used by \cite{Enck2011} for post-decompilation optimization tasks.\footnote{See \cite{Enck2011}, p. 5.}
The data flow is analysed by scanning an intermediate byte code format provided by \textit{Soot} for so called 'sources' and 'sinks'.\footnote{See \cite{Arzt2014}, p. 264.}
A source is the origin of a data flow, for instance the user input of data via a textfield and a sink is the destination that data flows.
An example for a sink is a HTTP internet connection or a local log file.
\textit{FlowDroid} is also able to emulate Android lifecycle entry points.
While a regular Java program has a single entry point to start the application from, the \textit{main()} function, Android apps provide multiple entry points.
The entry points of an Android app are determined by the states an app can be in. 
It can for instance return from being in the background, do a fresh start and return from being offline.
All these entry points are being emulated by \textit{FlowDroid} into a single \textit{main()} function call.
The output of the data flow analysis is one XML file per analysed APK file that contains a list of sinks and the coherent sources of data flows to that sink.
The XML file will be parsed by the main \sca tool later on and the sink and source methods will be interpreted in the context of information privacy risks.

The machine learning text classifiers will be trained within the second preparation step.
During the \sca phase of this study, we will be making great use of the naive Bayes classifier.
A machine learning text-classifier classifies text segments into distinct categories. 
The categories are predefined in the training phase of the classifier, since every trained text segment is assigned with a training category.
These training categories are the categories the classifier can assign to new, previously unseen, text segments.
The incisive feature of a Bayes classifier is the fact, that it chooses to classify a category to a new segment of text by picking the most probable category.\footnote{For this and the following two sentences see \cite{Rish2001}, p. 41.}
A \nbc furthermore assumes that all categories are distinct and independent of each other. 
Even though this might not always be the case in a real life usage scenario, the \nbc still performs well enough for a wide range of use cases.

In the case of the \sca in this study, we will be using the \nbc to classify URLs into categories.
The categories that URLs can belong to, in the context of this study, are: advertisement, delivery services, government, instant-messaging, (data-) aggregation services, search engines and social networks.
While the set of categories might not complete in terms of all possible and available categories, it is sufficient for the classification of URLs within this \sca to classify into the mentioned category-set.
In oder for the \nbc to classify text into categories we trained a \nbc implementation with meta-information about URLs from the previously mentioned categories.
First, it was necessary to collect URLs for the categories to train the \nbc and we used a collection of \acs{URL}s from \textit{URLBlacklist.com}\footnote{\url{https://web.archive.org/web/20160617050003/http://urlblacklist.com/?sec=download}, visited 06/17/16.}.
\textit{URLBlacklist.com} provides URL lists for the categories advertisement, government, instant-messaging, search engines and social networks.
\textit{programmableweb.com} catalogues API descriptions including the service providers' URL.
We developed a program to automatically download and store the API directory for the two remaining categories, from \textit{programmableweb.com}.

Next, to acquire meta-information for all the URLs, we implement a downloader for the HTML source-code of all URLs and store the 'description' HTML-meta tag content in a file.\footnote{For this and the next sentence see \url{https://web.archive.org/web/20160404111603/http://www.w3.org/wiki/HTML/Elements/meta}, visited 07/13/16.}
The 'description' meta-tag contains a small amount of text, provided by the website owner, that describes the content or function of the website topic.
We use this 'description' meta-information to train the classifier with the associated categories.\newline

As soon as the preparation steps are finished, the main \sca tool is ready to perform the \ipr analysis.
We call the main \sca tool '\textit{AIPRAT}', short for \aiprat from here on.
The fundamental concept of \AIPRAT is to iterate over all available apps and apply a set of analysis operations, called 'strategies', to the source code of these apps.
A strategy tries to identify \iprfs by applying algorithms, for instance feature extraction or text search, to parts of the app source code.
There are two types of strategies in the AIPRAT: generic and specific strategies.

% Generic strategies
Generic strategies are strategies that contain algorithms that are configurable and usable by specific strategies.
Generic strategies are the core of the \aiprat and every non-generic strategy inherits or uses a generic strategy to accomplish its \ipr detection task.
The generic strategies of the \aiprat will therefore be explained in more detail.
In total the \aiprat contains eight generic strategies in the Java-package \textit{analyze.src.strategies}: DataFlowStrategy, ExistenceStrategy, InputStrategy, TraceBackStrategy, InformationCollectionStrategy, PermissionStrategy, ProviderUrlStrategy, and UrlCategoryStrategy.
\lstinputlisting[float=h, language=Java, label=listing:DataFlowStrategy, caption=Generic strategy DataFlowStrategy.java parses pre-extracted dataflow XML files]{DataFlowStrategy.java}
% DataFlowStrategy
The DataFlowStrategy parses the pre-extracted dataflow \acs{XML} from the \textit{FlowDroid} preparation phase and allows iterating over all identified dataflow sources and sinks.
Thereby, the DataFlowStrategy allows to pass parameters along that filter the sources and sinks for certain search words and provide feedback if the search words were found within sources and sinks.
The filtering if the searched sources of sinks are included can be seen in lines 5 and 13 of listing \ref{listing:DataFlowStrategy}.
% ExistenceStrategy
To find strings within the source code of an app, one can make use of the ExistenceStrategy.
The ExistenceStrategy is shown in listing \ref{listing:ExistanceStrategy}.
This generic strategy scans the full source code of an app and collects source code lines that match a given search pattern (See lines 5-6 of listing \ref{listing:ExistanceStrategy}).
\lstinputlisting[float=h, language=Java, label=listing:ExistanceStrategy, caption=Generic strategy ExistanceStrategy.java to find the existance of search words within source code]{ExistanceStrategy.java} 
% InputStrategy
The InputStrategy iterates over all \acs{XML} layout configuration files of an app. 
User interface controls that are displayed within an app are declared in these \acs{XML} layout configuration files.
The InputStrategy tries to identify all user input fields and therefore scans the layout files for the search terms 'EditText', 'AutoCompleteTextView', 'CheckBox', 'RadioButton' and 'RadioGroup' (see lines 4-5 of listing \ref{listing:InputStrategy}).
As soon as a user input field has been found, the InputStrategy extracts all meta information about this input field possible (see line 6 of listing \ref{listing:InputStrategy}).
The input fields meta information generally contain the user interface control 'id', a 'hint' field and a 'text' field. 
The meta information are collected and stored together with the input field information.
\lstinputlisting[float=h, language=Java, label=listing:InputStrategy, caption=The InputStrategy.java identifies user input fields and extracts their meta information]{InputStrategy.java}
% TraceBackStrategy
An important feature in static code analysis, especially for assessing information privacy risks, is the ability to trace data flows from a source to a sink.
With the help of the call graph construction feature of \textit{FlowDroid}, the TraceBackStrategy starts at a given set of start-sinks and traverses the call graph back until either a source is found or a given search pattern is matched, as seen in line 22 of listing \ref{listing:TraceBackStrategy}.
This allows consequent strategies to define a search pattern for data flows to specific sinks.
In the case of this thesis, we will mainly use the TraceBackStrategy to find data flows that end in a information collection scenario. 
We define information collection as a data flow that results in storing the information either locally on the device the app is run, or that results in sending the information to a remote server.
\lstinputlisting[float=h, language=Java, label=listing:TraceBackStrategy, caption=Excerpt of the generic strategy TraceBackStrategy.java to trace defined information sources to information sinks via dataflow analysis]{TraceBackStrategy.java}
% InputInformationCollectionStrategy
With making use of the InputStrategy and the TracebackStrategy, the InputInformationCollectionStrategy takes the user input fields analysis one step further and allows for information collection analysis.
\lstinputlisting[float=h, language=Java, label=listing:InputInformationCollectionStrategy, caption=The InputInformationCollectionStrategy takes the user input fields analysis and tries to identify information collection data flows]{InputInformationCollectionStrategy.java}
First, all user input fields are detected and stored, as seen in line 3 of listing \ref{listing:InputInformationCollectionStrategy}. 
In a second step, the InputInformationCollectionStrategy executes a TraceBackStrategy that starts at all available information collection sinks (local file storage and remote server connections) and traces back the call graph in an attempt to identify the user input field 'ids' within the call graph path (see lines 10-12 of listing \ref{listing:InputInformationCollectionStrategy}).
If a user input field is found, a data flow towards an information collection sink is identified and a potential \ipr is detected.
% PermissionStrategy
A less sophisticated approach is being used by the PermissionStrategy, shown in listing \ref{listing:PermissionStrategy}.
It is required for Android apps to declare permissions to use certain features, such as the \acs{GPS} location or internet access, within the 'manifest' file.\footnote{See \url{https://web.archive.org/web/20160425141027/https://developer.android.com/training/permissions/declaring.html}, visited 08/16/16}
The PermissionStrategy enables a search through these permissions by a given search pattern (see line 6 of listing \ref{listing:PermissionStrategy}).
\lstinputlisting[float=h, language=Java, label=listing:PermissionStrategy, caption=Generic strategy PermissionStrategy.java to find the existance of Android permissions declarations]{PermissionsStrategy.java}

The last two generic strategies concern the \acs{URL}s that are listed within the app source code and that are potentially target to information collection.
The ProviderUrlStrategy iterates over all extracted URLs found within the source code and checks how similar the URL host is in comparison to the app package name (see line 8 of listing \ref{listing:ProviderUrlStrategy}).
We observed that the package name often is similar to the hostname of the app provider or contains similar name parts. 
The ProviderUrlStrategy takes these potential sub-parts of the package name into account and returns a probability that a URL connection to the app provider is established (see line 12 of listing \ref{listing:ProviderUrlStrategy}.
\lstinputlisting[float=h, language=Java, label=listing:ProviderUrlStrategy, caption=Generic strategy ProviderUrlStrategy.java tries to identify URL connections to the app provider domain]{ProviderUrlStrategy.java}

Finally, the URLCategoryStrategy enables a search for a given category of URLs within the app source code.
All URLs are classified into distinct categories upon loading the app into the \sca tool via a machine learning text classification technique.
The classified categories are: 'ads', 'aggregation', 'delivery', 'government', 'instantmessaging', 'searchengines', 'socialnetworks' and 'storage'.
In order to check if a URL of a certain category exists, the URLCategoryStrategy iterates over all classified URLs and matches their categories to the search category, as seen in lines 7-8 of listing \ref{listing:URLCategoryStrategy}).
\lstinputlisting[float=h, language=Java, label=listing:URLCategoryStrategy, caption=The URLCategoryStrategy.java queries for the existance of URLs of a specific category within the app source code]{URLCategoryStrategy.java}

% Specific strategy
A specific strategy, on the other hand, targets the exploration of an \ipp directly and contains the \ipp hierarchy identifier, introduced by \textcite{Dehling2016}, in its Java-classname.\footnote{See \cite{Dehling2016}, p. 6.}
The Java-class \textit{analyze.src.strategies.CI213\textunderscore Strategy} contains a search pattern for the \ipp with the hierarchy identifier CI213, which refers to the \ipp Content (C) $\rightarrow$ InformationCollectionContent (I) $\rightarrow$ InformationCollectionSensorContent (2) $\rightarrow$ EnvironmentSensorContent (1) $\rightarrow$ MicrophoneContent (3).
Therefore a specific strategy may contain a combination of one or many generic strategies to try to identify the risk of the associated \ipp is posing through static code analysis.
In the example of the specific strategy \textit{analyze.src.strategies.CI213\textunderscore Strategy}, the class extends the generic strategy class \textit{analyze.src.strategies.ExistenceStrategy} and sets the search parameters of the \textit{ExistenceStrategy} to 'MediaRecorder.setAudioSource(' and 'MediaRecorder.AudioSource.MIC'.
The \textit{CI213\textunderscore Strategy} class scans via the parent-class \textit{ExistenceStrategy} all of the source code files off the app for source code that uses the Android microphone \acs{API}.

\begin{table}
	\begin{center}

	\begin{tabular}{ | p{4.8cm} | p{9cm} | }
	\hline
		ExistenceStrategy & CH21, CH23, CH310, CH311, CH312, CH33, CH35, CH38, CH43, CH44, CI212, CI213, CI214, CI221, CI222, CI223, CI231, CI242, CI243 \\ \hline
		InputInformationCollection-Strategy & CI321, CI322, CI323, CI324, CI325, CI326, CI341, CI343, CI344, CI345, CI346 \\ \hline
		InputStrategy & CI314 \\ \hline
		PermissionsStrategy & CH43, CH44, CI211, CI212, CI214, CI231 \\ \hline
		ProviderUrlStrategy & CH45 \\ \hline
		TraceBackStrategy & CH22, CH42, CH45, CI221, CI311, CI312, CI315, CI333, CI335, CI336 \\ \hline
		UrlCategoryStrategy & CH34, CH36, CH37, CH46 \\ \hline
	\end{tabular}
	\end{center}
	
	\caption{Specific strategies in relation to the generic strategies that they use} 
	\label{table:specStrategies}
\end{table}

% Explain specific strategies in more detail
In the following section we will introduce the specific strategies implemented in the \aiprat in greater detail.
Table \ref{table:specStrategies} displays and overview of the generic strategies in the first column and the specific strategies that make use of the coherent generic strategies in the second column.
The specific strategy classes in this chapter and in table \ref{table:specStrategies} are abbreviated with the \ipp hierarchy identifier of the matching strategy. 
\textit{CH21} for example stands for \textit{CH21\textunderscore Strategy.java} in this chapter.

% ExistenceStrategy
\textit{ExistenceStrategy}.
The generic ExistenceStrategy ist the most widely used strategy within the analysis tool.
% CH21
The strategy \textit{CH21} uses the ExistanceStrategy to check for the existance of the search words 'cipher' and 'crypt' that would indicate encryption during processing of data.
% CH23
Strategy \textit{CH23} uses the ExistenceStrategy twice to check if data transfers are secure. 
First strategy \textit{CH23} checks for the existence count of HTTP connections and second, it check for the existence count of HTTPS connections.
The result of \textit{CH23} is the ratio of \acs{HTTP} to \acs{HTTPS} connections.
% CH310 & CH312 & CH38
The strategies \textit{CH310}, \textit{CH311}, \textit{CH312} and \textit{CH38} try to identify a user initiated sharing of content with other users or the general public.
The strategies accomplish this by searching the source code of an app for triggering the Android sharing dialog window.
Additionally we search for methods that open sharing dialogs to three large social media networks, \textit{facebook}, \textit{twitter}, and \textit{Google+}.
% CH33
Strategy \textit{CH33} uses the generic ExistenceStrategy extensively to identify the usage of advertisement libraries within the app.
All search words are names of Android advertisement library identifiers and are derived from the analysis of Android ad libraries by \cite{Book2013}.\footnote{See \cite{Book2013}, p. 9.}
% CH35
In order to scan the source code of an app for the usage of analytics services, as stated in the hierarchy item \textit{CH35}, the strategy implementation for \textit{CH35} uses the ExistenceStrategy to check for analytics services and libraries search words.
The search words are derived from the open-source listing of Android libraries on https://android-arsenal.com in the category 'Analytics'.\footnote{\url{http://web.archive.org/web/20160514040053/http://android-arsenal.com/tag/5}, visited 07/03/16.}
% CH43 & CH44
\textit{CH43} and \textit{CH44} search for function names that indicate a writing of data to the internal or external storage of an Android device.
Internal and external storage can be a local database that every Android app instance can write to, the filesystem or a 'shared preferences' key value store, provided by the Android runtime.
Internal storage refers to storage of data on the devices' flash memory itself and external storage refers to storage of data on inserted storage mediums, such as storage card.
% CI212
Usage of the Android devices' internal camera is accomplished via a standardised \acs{API}.
In order to detect the usage of the internal camera, the \textit{CI212} strategy searches for the code snippets that are designated to launch the camera view inside of an Android app.
% CI213
A similar approach is used by the \textit{CI213} strategy, that aims at identifying the usage of the microphone recording by utilizing the ExistenceStrategy to find microphone calling function names.
% CI214
\textit{CI214} searches the source code for the usage of the Android near-field communication (\acs{NFC}) API, via the ExistenceStrategy.
The Android API has one particular method call to initiate a NFC connection, so detecting this feature via the ExistenceStrategy is effortless.
% CI221, CI222 & CI223
The strategies for \textit{CI221}, \textit{CI222} and \textit{CI223} utilize the ExistenceStrategy to detect wether the user's location is queried.
This can either happen by calling the Global Positioning System (\acs{GPS}) location, or by using the approximate location via the internet network connections of the device.
% CI231
A fairly new technique to smart-devices is the usage of a fingerprint sensor. 
This functionality is exposed via a single API entry-point in Android and can be detected by the \textit{CI231} strategy using the ExistenceStrategy.
% CI242
Also exposed via a single API entry-point is the ability to store and retrieve cookies\footnote{Cookies are pieces of information stored on the client device, accessible only by the provider that stored the cookie information until they expire. See \cite{Laudon2010}, p. 168.}.
Therefore the \textit{CI242} strategy can effortlessly detect the usage of such cookies within an app.
% CI243
More difficult is the detection of potential user surveys within an app.
\textit{CI243} uses the ExistenceStrategy to search the app source code for search words such as 'survey', 'audit' and 'syllabus'.

% InputInformationCollectionStrategy
\textit{InputInformationCollectionStrategy}. The following strategies try to identify dataflows from text input fields to information collection sinks.
% CI321
\textit{CI321} tries to identify dataflows from financial identification input fields. 
Financial identifier text input fields will be identified by using the search words: 'creditcard', 'cvc', 'iban', 'bic', 'bankaccount', 'bank', 'mastercard', 'paypal' and 'visa'.
If none of the search words are found within the identifiers of text input fields the certainty property of the result object is set to \textit{MEDIUM}.
This is because the list of search words might not be complete or the text input field are named in a non expressive way.
For example the text input fields might be named 'id=123456' instead of something expressive such as 'id=txtIBAN'.
The just explained certainty property value '\textit{MEDIUM}' for non-found input information collection dataflows holds true for the rest of the following strategies that use the InputInformationCollectionStrategy.
% CI322
Strategy \textit{CI322} tries to recognize government identifier dataflows within the app and uses the search words 'socialsecurity', 'insurance', 'tax', 'SSN', 'national', 'government' and 'identification'.
% CI323
\textit{CI323} only needs to identify the information collection of the name of the users, it utilizes the InputInformationCollectionStrategy with the search word 'name'. 
This automatically includes a search for 'surname' and for example 'middlename', since the InputInformationCollectionStrategy always performs a substring search within the text input field identifiers.
% CI324
The search words to identify an online contact of users are more definite.
Online contact information refers to the different ways users can be contacted online, for example via 'email', 'skype', 'facebook', 'twitter', 'chat' and many more.
\textit{CI324} uses the previously mentioned search words to identify dataflows of online contact information to information collection sinks.
% CI325
In contrast to the online contact information, the strategy for \textit{CI325} tries to identify information collection of physical contact information.
This refers to the address of users or their phone number.
% CI326
To identify users within an app itself, app providers implement their own unique user identifiers into the apps.
A unique user identifier could be a username, email address, and assigned Universally Unique Identifier (\acs{UUID}) or a password.
These unique user identifier information collection dataflows are detected by strategy \textit{CI326}.
% CI341
Strategy \textit{CI341} detects information collection of demographic information.
The search words for demographic information are derived from the survey recommendations for demographic standards from the German 'Statistisches Bundesamt'.\footnote{\raggedright See \url{https://web.archive.org/web/20151115091328/https://www.destatis.de/DE/Methoden/DemografischeRegionaleStandards/Fragebogen_schriftlich.pdf?__blob=publicationFile}, visited 07/05/16.}
% CI343
The strategy \textit{CI343} tries to identify users health information collection dataflows.
Here, the search words are derived from the manual review of mHealth apps by \textcite{Bruggemann2016}. 
The extensive health content search words are 'dosage', 'pill', 'blood', 'heart', 'bloodpressure', 'bloodsugar', 'heartrate', 'disease', 'symptom', 'weight', 'height', 'body', 'bmi', 'temperature', 'medical', 'doctor', 'calories', 'diet', 'sleep', 'carbon', 'hydrate', 'intake', 'haemoglobin', 'anaesthetic', 'urine' and 'hospital'.
% CI344
Ideological content, such as believes or membership of religious or political groups, information collection is detected by the strategy \textit{CI344}.
Input fields asking for membership of political parties for example, could be designed as option choice buttons and are captured by the InputInformationCollectionStrategy as well.
% CI345
Preferences of the users are difficult to capture, since preference-capturing input fields usually are connected to some sort of context, that users are asked their preferences about.
For the sake of this thesis, we will scan the input fields for expressions of preference, for example: 'like', 'dislike', 'favourite', 'favorite', 'preference' and 'prefered'.
We acknowledge that in case we did not find any preference capturing input field information collection, the certainty for this is at a level \textit{'LOW'}.
It is much more likely that we were unable to identify the information collection in that case.
% CI346
The last strategy using the generic InputInformationCollectionStrategy is the strategy for \textit{CI346}. 
Strategy \textit{CI346} tries to identify information collection of user device information, such as the Internet Protocol (\acs{IP}) address or the operating system name.

% InputStrategy
\textit{InputStrategy}. The generic InputStrategy is only used by a single specific strategy.
The strategy for \textit{CI314} tries to detect and list all of the input fields a user can input information into, within the app.
This is done by executing the InputStrategy, explained earlier in this chapter.

% PermissionsStrategy
\textit{PermissionsStrategy}.
% CH43 & CH44
The strategies for \textit{CH43} and \textit{CH44} check, as an additional condition, if a permission to write on external and internal storage is requested.
Only if a permission is declared, an app is allowed to use the coherent functionality of the Android API.
This is granted by the Android runtime.
% CI211
The strategy for \textit{CI211} relies solely on the generic PermissionsStrategy to identify the usage of Bluetooth functionality within the app.
An Android app is not granted access to the Bluetooth interface, if it does not declare the appropriate permission.
\textit{CI211} uses the PermissionsStrategy only, because Bluetooth interface APIs are not standardized and not easy to detect individually.
To 
% CI212 & CI214 & CI231
The previously described strategy implementations for \textit{CI212}, \textit{CI214} and \textit{CI231} behave in the same way as \textit{CH43} and \textit{CH44}.
They use the PermissionsStrategy as an additional condition, to detect the usage of the camera, near field communication \acs{NFC} and the fingerprint sensor.

% ProviderUrlStrategy
\textit{ProviderUrlStrategy}.
% CH45
The only specific strategy using the generic ProviderUrlStrategy is the strategy for \textit{CH45}.
It uses a list of all potential URLs that belong to the app provider, to identify information collection that sends data to the app providers servers.

% TraceBackStrategy
\textit{TraceBackStrategy}.
% CH45
Strategy \textit{CH45} uses, additionally to the ProviderUrlStrategy, the generic TraceBackStrategy.
It traces information collection flows to the previously detected app provider URLs.
% CH22
Dataflows that result in file storage on the internal flash drive or an external storage card can also be identified with the generic TraceBackStrategy.
The strategy for \textit{CH22} walks up the callgraph of all local storage collection sinks and checks if a function name containing the search words 'cipher' and 'crypt' was found along the way.
This would indicate that data stored on the local storage is stored in an encrypted way.
% CH42
Strategy \textit{CH42} tries to identify information collection at cloud storage providers.
Since it is virtually impossible to know, list and check for every possible cloud storage provider, the strategy searches for the word 'cloud' within dataflows that result in an information collection sink.
We acknowledge the low probability of actually finding a cloud storage dataflow with this technique by setting the certainty level of the result to \textit{'LOW'} by default.
% CI221 & CI333
A much higher success rate is promised by the standardized Android API to query the users location.
Detecting dataflows from these location queries to information collection sinks is done by the \textit{CI221} and \textit{CI333} strategies, mainly by searching for the usage of the 'LocationManager' object in Java.
The 'LocationManager' is the single point of entry to query the users location.
% CI311
A similar unambiguity is present for the detection of audio information collection.
While the callgraph is being traversed, strategy \textit{CI311} tries to identify function calls that contains the following search words: 'microphone', 'audio', 'recorder', 'mediarecorder', 'music' and 'sound'.
% CI312
The strategy for \textit{CI312} tries to detect the information collection of image information and therefore uses the search words 'picture', 'ACTION\textunderscore IMAGE\textunderscore CAPTURE', 'MEDIA\textunderscore TYPE\textunderscore IMAGE', 'CAPTURE\textunderscore IMAGE', 'image', 'setImageDrawable' and 'Bitmap'.
Central to image processing in Android is the 'Bitmap' object, as it is the binary representation of an image.
Detecting the usage of the 'Bitmap' object in an information collection callgraph path therefore yields a potential image information collection.
% CI315
The same holds true for strategy \textit{CI315}. 
In comparison to \textit{CI312}, \textit{CI315} tries to detect the information collection of video information.
Video processing in Android works immaturely different, than photo processing.
Instead of manipulating a 'Bitmap' object, as for the photo processing, videos are stored by the Android API and accessible via an uniform resource identifier (\acs{URI}).\footnote{\raggedright See \url{http://web.archive.org/web/20160425094249/https://developer.android.com/training/camera/videobasics.html}, visited 07/09/16}
Therefore the \textit{CI315} strategy can only detect video capturing information collection.
% CI335 
Strategy \textit{CI335} identifies information collection of the users contacts stored in his address book.
Querying the contacts via the Android API is always done via the 'ContactsContract' object.
The \textit{CI335} strategy can therefore easily detect information collection dataflows of users contacts by using the TraceBackStrategy.
% CI336
The last specific strategy to use the generic TraceBackStrategy is \textit{CI336} that tries to find information collection data flows on purchase information.

% UrlCategoryStrategy
\textit{UrlCategoryStrategy}.
As explained earlier in this chapter, the generic UrlCategoryStrategy preloads its training data of \acs{URL} classification into main memory at program start-time.
From then on, the UrlCategoryStrategy can be queried if certain URL categories are present within the currently inspected app. 
% CH34
Strategy \textit{CH34} searches for URLs that belong to a data aggregation service that potentially aggregates the users data.
% CH36
The \textit{CH36} strategy searches for URL connections to delivery services.
Delivery services can be postal service, package shipping or other logistic services.
% CH37
URLs to government institutions are identified by the \textit{CH37} strategy using the generic UrlCategoryStrategy.
% CH46
Finally, the \textit{CH46} strategy tries to detect URL connections to storage providers.
Storage providers refers to cloud storage or bulk data storage services that allow external data storage.

% Evaluation of an Automated Information Privacy Risk Assessment Tool
\subsection{Evaluation of an Automated Information Privacy Risk Assessment Tool}\label{chapter:evaluationMethods}

In order to evaluate how well the \aiprat is performing in comparison to a human researcher, we analyze a sample of three apps by two human researchers
The apps that will be chosen to be reviewed by human researchers will be the three apps with the most \ipr found by the \aiprat beforehand.
Each researcher is presented with the source code of the selected apps and the list of relevant information privacy practices to identify.
The task for each researcher is to identify as many \ipp as possibly by analyzing, searching and reading through the source code files. 
This will result in an overview comparison on how well the \aiprat performs in comparison to a human.

We acknowledge that a human app reviewer can almost find any \ipp risk within the app source code given enough time.
In order to find an appropriate time range that the human review should spend analyzing a single app, we looked at common review times of app stores today.
The Google PlayStore does not manually review newly uploaded apps, while the Apple AppStore does apply manual review to each and every app update.
The average time it takes for an app to pass the Apple AppStore review, which also includes waiting in a queue to be reviewed, is currently two days.\footnote{See \url{http://web.archive.org/web/20160513013009/http://appreviewtimes.com/}, visited 05/13/16.}
In order to keep the review times at a realistic level, a human app reviewer of our test sample apps should therefore not spend more than two days on analyzing a single app.

The reviewers will document their results in a tabular form, for each app.
For each of the relevant \ipp the reviewers will mark if they were able to detect the \ipr the \ipp poses or not.
Additionally they will report the certainty with which they feel that they detected the information privacy practice.
The certainty levels are \textit{LOW}, \textit{MEDIUM}, \textit{HIGH}.

A \textit{HIGH} certainty expresses, that the reviewers are very confident that they found the \ipp in question.
A \textit{LOW} certainty indicates that the reviewers found a potential indicator for an \ipp but is rather uncertain if this is indication expresses the full \ipp or if there are not any other indicators for the \ipp that were not found yet or are unfindable.
To express a neither high nor low certainty about a \ipp found, the reviewers can use a \textit{MEDIUM} certainty level.

Afterwards we will compare the results with the \ipr found by the \aiprat and draw conclusions from the comparison.